Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    SHORT
    RETURN
    VOID
    NE
    UMINUS
    WHILE
    COLON
    TERNARY
    MINUS
    CCHAR
    LE
    RPAREN
    UNSIGNED
    LT
    PLUS
    PERIOD
    FUNCTION
    GT
    MODULO
    DIVIDE
    FOR
    CSTRING
    EQUALS
    RBRACE
    ELSE
    GE
    LPAREN
    TIMES
    EQ
    IF
    AND
    LBRACE
    BREAK
    CONTINUE
    NOT
    CINT
    OR

Grammar

Rule 0     S' -> program
Rule 1     program -> program global_statement
Rule 2     program -> global_statement
Rule 3     global_statement -> variable_declaration
Rule 4     variable_declaration -> type id_list SEMI
Rule 5     type -> INT
Rule 6     type -> CHAR
Rule 7     type -> STRING
Rule 8     id_list -> id_list COMMA ID
Rule 9     id_list -> ID

Terminals, with rules where they appear

AND                  : 
BREAK                : 
CCHAR                : 
CHAR                 : 6
CINT                 : 
COLON                : 
COMMA                : 8
CONTINUE             : 
CSTRING              : 
DIVIDE               : 
ELSE                 : 
EQ                   : 
EQUALS               : 
FOR                  : 
FUNCTION             : 
GE                   : 
GT                   : 
ID                   : 8 9
IF                   : 
INT                  : 5
LBRACE               : 
LE                   : 
LPAREN               : 
LT                   : 
MINUS                : 
MODULO               : 
NE                   : 
NOT                  : 
OR                   : 
PERIOD               : 
PLUS                 : 
RBRACE               : 
RETURN               : 
RPAREN               : 
SEMI                 : 4
SHORT                : 
STRING               : 7
TERNARY              : 
TIMES                : 
UMINUS               : 
UNSIGNED             : 
VOID                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

global_statement     : 1 2
id_list              : 4 8
program              : 1 0
type                 : 4
variable_declaration : 3

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program global_statement
    (2) program -> . global_statement
    (3) global_statement -> . variable_declaration
    (4) variable_declaration -> . type id_list SEMI
    (5) type -> . INT
    (6) type -> . CHAR
    (7) type -> . STRING

    INT             shift and go to state 2
    CHAR            shift and go to state 3
    STRING          shift and go to state 1

    program                        shift and go to state 4
    type                           shift and go to state 6
    variable_declaration           shift and go to state 7
    global_statement               shift and go to state 5

state 1

    (7) type -> STRING .

    ID              reduce using rule 7 (type -> STRING .)


state 2

    (5) type -> INT .

    ID              reduce using rule 5 (type -> INT .)


state 3

    (6) type -> CHAR .

    ID              reduce using rule 6 (type -> CHAR .)


state 4

    (0) S' -> program .
    (1) program -> program . global_statement
    (3) global_statement -> . variable_declaration
    (4) variable_declaration -> . type id_list SEMI
    (5) type -> . INT
    (6) type -> . CHAR
    (7) type -> . STRING

    INT             shift and go to state 2
    CHAR            shift and go to state 3
    STRING          shift and go to state 1

    type                           shift and go to state 6
    variable_declaration           shift and go to state 7
    global_statement               shift and go to state 8

state 5

    (2) program -> global_statement .

    INT             reduce using rule 2 (program -> global_statement .)
    CHAR            reduce using rule 2 (program -> global_statement .)
    STRING          reduce using rule 2 (program -> global_statement .)
    $end            reduce using rule 2 (program -> global_statement .)


state 6

    (4) variable_declaration -> type . id_list SEMI
    (8) id_list -> . id_list COMMA ID
    (9) id_list -> . ID

    ID              shift and go to state 10

    id_list                        shift and go to state 9

state 7

    (3) global_statement -> variable_declaration .

    INT             reduce using rule 3 (global_statement -> variable_declaration .)
    CHAR            reduce using rule 3 (global_statement -> variable_declaration .)
    STRING          reduce using rule 3 (global_statement -> variable_declaration .)
    $end            reduce using rule 3 (global_statement -> variable_declaration .)


state 8

    (1) program -> program global_statement .

    INT             reduce using rule 1 (program -> program global_statement .)
    CHAR            reduce using rule 1 (program -> program global_statement .)
    STRING          reduce using rule 1 (program -> program global_statement .)
    $end            reduce using rule 1 (program -> program global_statement .)


state 9

    (4) variable_declaration -> type id_list . SEMI
    (8) id_list -> id_list . COMMA ID

    SEMI            shift and go to state 12
    COMMA           shift and go to state 11


state 10

    (9) id_list -> ID .

    SEMI            reduce using rule 9 (id_list -> ID .)
    COMMA           reduce using rule 9 (id_list -> ID .)


state 11

    (8) id_list -> id_list COMMA . ID

    ID              shift and go to state 13


state 12

    (4) variable_declaration -> type id_list SEMI .

    INT             reduce using rule 4 (variable_declaration -> type id_list SEMI .)
    CHAR            reduce using rule 4 (variable_declaration -> type id_list SEMI .)
    STRING          reduce using rule 4 (variable_declaration -> type id_list SEMI .)
    $end            reduce using rule 4 (variable_declaration -> type id_list SEMI .)


state 13

    (8) id_list -> id_list COMMA ID .

    SEMI            reduce using rule 8 (id_list -> id_list COMMA ID .)
    COMMA           reduce using rule 8 (id_list -> id_list COMMA ID .)

